#!/usr/bin/env node

/**
 * Script para limpeza autom√°tica do Supabase Storage
 * 
 * Remove arquivos com mais de 30 dias dos buckets configurados
 * 
 * Uso:
 * node scripts/cleanup-storage.js [--dry-run] [--days=30] [--bucket=nome]
 * 
 * Exemplos:
 * node scripts/cleanup-storage.js --dry-run
 * node scripts/cleanup-storage.js --days=7
 * node scripts/cleanup-storage.js --bucket=files
 */

require('dotenv').config({ path: '.env.local' });
const { createClient } = require('@supabase/supabase-js');
const { Client } = require('pg');

// Configura√ß√£o
const DEFAULT_RETENTION_DAYS = 30;
const BUCKETS_TO_CLEAN = ['files', 'screenshots', 'avatars'];

// Cliente Supabase
const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL,
  process.env.SUPABASE_SERVICE_ROLE_KEY,
  {
    auth: {
      autoRefreshToken: false,
      persistSession: false
    }
  }
);

// Cliente PostgreSQL para consultas diretas
const pgClient = new Client({
  connectionString: process.env.POSTGRES_URL
});

/**
 * Fun√ß√£o para calcular data de corte
 */
function getCutoffDate(days) {
  const cutoff = new Date();
  cutoff.setDate(cutoff.getDate() - days);
  return cutoff;
}

/**
 * Fun√ß√£o para formatar tamanho em bytes
 */
function formatBytes(bytes) {
  if (bytes === 0) return '0 Bytes';
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

/**
 * Fun√ß√£o para listar arquivos antigos em um bucket
 */
async function listOldFiles(bucketName, cutoffDate) {
  try {
    console.log(`üîç Verificando bucket: ${bucketName}`);
    
    // Listar todos os arquivos do bucket
    const { data: files, error } = await supabase.storage
      .from(bucketName)
      .list('', {
        limit: 1000,
        sortBy: { column: 'created_at', order: 'asc' }
      });

    if (error) {
      console.error(`‚ùå Erro ao listar arquivos do bucket ${bucketName}:`, error.message);
      return [];
    }

    if (!files || files.length === 0) {
      console.log(`üìÅ Bucket ${bucketName} est√° vazio`);
      return [];
    }

    // Filtrar arquivos antigos
    const oldFiles = files.filter(file => {
      const fileDate = new Date(file.created_at);
      return fileDate < cutoffDate;
    });

    console.log(`üìä ${bucketName}: ${files.length} arquivos total, ${oldFiles.length} para remo√ß√£o`);
    
    return oldFiles.map(file => ({
      bucket: bucketName,
      name: file.name,
      size: file.metadata?.size || 0,
      created_at: file.created_at,
      path: file.name
    }));

  } catch (error) {
    console.error(`‚ùå Erro inesperado no bucket ${bucketName}:`, error.message);
    return [];
  }
}

/**
 * Fun√ß√£o para remover arquivos de um bucket
 */
async function removeFiles(bucketName, filePaths, dryRun = false) {
  if (filePaths.length === 0) {
    return { success: 0, failed: 0, bytes: 0 };
  }

  let successCount = 0;
  let failedCount = 0;
  let totalBytes = 0;

  console.log(`üóëÔ∏è  ${dryRun ? '[DRY RUN] ' : ''}Removendo ${filePaths.length} arquivos do bucket ${bucketName}`);

  // Processar em lotes de 50 arquivos
  const batchSize = 50;
  for (let i = 0; i < filePaths.length; i += batchSize) {
    const batch = filePaths.slice(i, i + batchSize);
    const paths = batch.map(file => file.path);

    if (dryRun) {
      console.log(`üìã [DRY RUN] Removeria ${paths.length} arquivos:`);
      paths.forEach(path => console.log(`   - ${path}`));
      successCount += paths.length;
      totalBytes += batch.reduce((sum, file) => sum + (file.size || 0), 0);
    } else {
      try {
        const { data, error } = await supabase.storage
          .from(bucketName)
          .remove(paths);

        if (error) {
          console.error(`‚ùå Erro ao remover lote:`, error.message);
          failedCount += paths.length;
        } else {
          console.log(`‚úÖ Removidos ${paths.length} arquivos com sucesso`);
          successCount += paths.length;
          totalBytes += batch.reduce((sum, file) => sum + (file.size || 0), 0);
        }
      } catch (error) {
        console.error(`‚ùå Erro inesperado ao remover lote:`, error.message);
        failedCount += paths.length;
      }
    }

    // Pequena pausa entre lotes para n√£o sobrecarregar
    if (i + batchSize < filePaths.length) {
      await new Promise(resolve => setTimeout(resolve, 100));
    }
  }

  return { success: successCount, failed: failedCount, bytes: totalBytes };
}

/**
 * Fun√ß√£o para verificar estat√≠sticas do storage
 */
async function getStorageStats() {
  try {
    await pgClient.connect();
    
    const query = `
      SELECT 
        bucket_id,
        COUNT(*) as file_count,
        SUM(metadata->>'size')::bigint as total_size
      FROM storage.objects 
      WHERE bucket_id IN ($1, $2, $3)
      GROUP BY bucket_id
      ORDER BY bucket_id;
    `;
    
    const result = await pgClient.query(query, BUCKETS_TO_CLEAN);
    return result.rows;
  } catch (error) {
    console.error('‚ùå Erro ao obter estat√≠sticas:', error.message);
    return [];
  } finally {
    await pgClient.end();
  }
}

/**
 * Fun√ß√£o principal de limpeza
 */
async function cleanupStorage(options = {}) {
  const {
    dryRun = false,
    retentionDays = DEFAULT_RETENTION_DAYS,
    specificBucket = null
  } = options;

  const cutoffDate = getCutoffDate(retentionDays);
  const bucketsToProcess = specificBucket ? [specificBucket] : BUCKETS_TO_CLEAN;

  console.log('üßπ LIMPEZA AUTOM√ÅTICA DO SUPABASE STORAGE');
  console.log('==========================================');
  console.log(`üìÖ Data de corte: ${cutoffDate.toISOString()}`);
  console.log(`‚è∞ Reten√ß√£o: ${retentionDays} dias`);
  console.log(`ü™£ Buckets: ${bucketsToProcess.join(', ')}`);
  console.log(`üîç Modo: ${dryRun ? 'DRY RUN (simula√ß√£o)' : 'EXECU√á√ÉO REAL'}`);
  console.log('');

  // Estat√≠sticas antes da limpeza
  console.log('üìä ESTAT√çSTICAS ANTES DA LIMPEZA:');
  const statsBefore = await getStorageStats();
  statsBefore.forEach(stat => {
    console.log(`   ${stat.bucket_id}: ${stat.file_count} arquivos, ${formatBytes(stat.total_size || 0)}`);
  });
  console.log('');

  let totalFilesProcessed = 0;
  let totalFilesRemoved = 0;
  let totalBytesCleaned = 0;
  let totalErrors = 0;

  // Processar cada bucket
  for (const bucket of bucketsToProcess) {
    try {
      const oldFiles = await listOldFiles(bucket, cutoffDate);
      totalFilesProcessed += oldFiles.length;

      if (oldFiles.length > 0) {
        const result = await removeFiles(bucket, oldFiles, dryRun);
        totalFilesRemoved += result.success;
        totalBytesCleaned += result.bytes;
        totalErrors += result.failed;
      }
    } catch (error) {
      console.error(`‚ùå Erro ao processar bucket ${bucket}:`, error.message);
      totalErrors++;
    }
    
    console.log(''); // Linha em branco entre buckets
  }

  // Relat√≥rio final
  console.log('üìã RELAT√ìRIO FINAL:');
  console.log('===================');
  console.log(`üìÅ Arquivos encontrados: ${totalFilesProcessed}`);
  console.log(`üóëÔ∏è  Arquivos ${dryRun ? 'que seriam removidos' : 'removidos'}: ${totalFilesRemoved}`);
  console.log(`üíæ Espa√ßo ${dryRun ? 'que seria liberado' : 'liberado'}: ${formatBytes(totalBytesCleaned)}`);
  console.log(`‚ùå Erros: ${totalErrors}`);
  
  if (dryRun) {
    console.log('');
    console.log('‚ö†Ô∏è  Este foi um DRY RUN. Para executar a limpeza real, remova a flag --dry-run');
  }

  return {
    processed: totalFilesProcessed,
    removed: totalFilesRemoved,
    bytes: totalBytesCleaned,
    errors: totalErrors
  };
}

/**
 * Fun√ß√£o para mostrar ajuda
 */
function showHelp() {
  console.log('üßπ SCRIPT DE LIMPEZA AUTOM√ÅTICA DO STORAGE');
  console.log('==========================================');
  console.log('');
  console.log('Uso:');
  console.log('  node scripts/cleanup-storage.js [op√ß√µes]');
  console.log('');
  console.log('Op√ß√µes:');
  console.log('  --dry-run              Simula a limpeza sem remover arquivos');
  console.log('  --days=N               Define reten√ß√£o em dias (padr√£o: 30)');
  console.log('  --bucket=nome          Limpa apenas o bucket especificado');
  console.log('  --help, -h             Mostra esta ajuda');
  console.log('  --stats                Mostra apenas estat√≠sticas');
  console.log('');
  console.log('Exemplos:');
  console.log('  node scripts/cleanup-storage.js --dry-run');
  console.log('  node scripts/cleanup-storage.js --days=7');
  console.log('  node scripts/cleanup-storage.js --bucket=files --dry-run');
  console.log('  node scripts/cleanup-storage.js --stats');
  console.log('');
  console.log('Buckets configurados:', BUCKETS_TO_CLEAN.join(', '));
  console.log('');
}

/**
 * Fun√ß√£o para mostrar apenas estat√≠sticas
 */
async function showStats() {
  console.log('üìä ESTAT√çSTICAS DO STORAGE');
  console.log('==========================');
  
  const stats = await getStorageStats();
  let totalFiles = 0;
  let totalSize = 0;
  
  stats.forEach(stat => {
    console.log(`üìÅ ${stat.bucket_id}:`);
    console.log(`   Arquivos: ${stat.file_count}`);
    console.log(`   Tamanho: ${formatBytes(stat.total_size || 0)}`);
    console.log('');
    
    totalFiles += parseInt(stat.file_count);
    totalSize += parseInt(stat.total_size || 0);
  });
  
  console.log('üìã TOTAL:');
  console.log(`   Arquivos: ${totalFiles}`);
  console.log(`   Tamanho: ${formatBytes(totalSize)}`);
}

/**
 * Fun√ß√£o principal
 */
async function main() {
  const args = process.argv.slice(2);
  
  // Parse de argumentos
  const options = {
    dryRun: args.includes('--dry-run'),
    retentionDays: DEFAULT_RETENTION_DAYS,
    specificBucket: null,
    showHelp: args.includes('--help') || args.includes('-h'),
    showStats: args.includes('--stats')
  };
  
  // Parse days
  const daysArg = args.find(arg => arg.startsWith('--days='));
  if (daysArg) {
    const days = parseInt(daysArg.split('=')[1]);
    if (isNaN(days) || days < 1) {
      console.error('‚ùå Valor inv√°lido para --days. Use um n√∫mero positivo.');
      process.exit(1);
    }
    options.retentionDays = days;
  }
  
  // Parse bucket
  const bucketArg = args.find(arg => arg.startsWith('--bucket='));
  if (bucketArg) {
    const bucket = bucketArg.split('=')[1];
    if (!BUCKETS_TO_CLEAN.includes(bucket)) {
      console.error(`‚ùå Bucket inv√°lido: ${bucket}`);
      console.error(`   Buckets dispon√≠veis: ${BUCKETS_TO_CLEAN.join(', ')}`);
      process.exit(1);
    }
    options.specificBucket = bucket;
  }
  
  // Mostrar ajuda
  if (options.showHelp) {
    showHelp();
    return;
  }
  
  // Mostrar estat√≠sticas
  if (options.showStats) {
    await showStats();
    return;
  }
  
  try {
    const result = await cleanupStorage(options);
    
    if (result.errors > 0) {
      console.log('');
      console.log('‚ö†Ô∏è  Limpeza conclu√≠da com alguns erros.');
      process.exit(1);
    } else {
      console.log('');
      console.log('‚úÖ Limpeza conclu√≠da com sucesso!');
      process.exit(0);
    }
  } catch (error) {
    console.error('‚ùå Erro fatal durante a limpeza:', error.message);
    process.exit(1);
  }
}

// Executar se chamado diretamente
if (require.main === module) {
  main();
}

module.exports = { cleanupStorage, listOldFiles, removeFiles, getStorageStats };