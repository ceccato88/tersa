'use server';

import { getSubscribedUser } from '@/lib/auth';
import { database } from '@/lib/database';
import { parseError } from '@/lib/error/parse';
import { logger, logServerAction, logApiCall } from '@/lib/logger';
import { visionModels } from '@/lib/models/vision';
import { projects } from '@/schema';
import { eq } from 'drizzle-orm';
import Replicate from 'replicate';

export const describeAction = async (
  url: string,
  projectId: string
): Promise<
  | {
      description: string;
    }
  | {
      error: string;
    }
> => {
  return logServerAction('describeAction', async () => {
    logger.info('ðŸ–¼ï¸ INICIANDO ANÃLISE DE IMAGEM', {
      input: { url, projectId },
      metadata: { action: 'image_description' }
    });

    try {
      // AutenticaÃ§Ã£o do usuÃ¡rio
      logger.debug('ðŸ” Verificando autenticaÃ§Ã£o do usuÃ¡rio');
      await getSubscribedUser();
      logger.info('âœ… UsuÃ¡rio autenticado com sucesso');

      // InicializaÃ§Ã£o do Replicate
      logger.debug('ðŸ¤– Inicializando cliente Replicate');
      const replicate = new Replicate({
        auth: process.env.REPLICATE_API_TOKEN,
      });
      logger.info('âœ… Cliente Replicate inicializado');

      // Busca do projeto
      logger.debug('ðŸ” Buscando projeto no banco de dados', {
        input: { projectId }
      });
      const project = await database.query.projects.findFirst({
        where: eq(projects.id, projectId),
      });

      if (!project) {
        logger.error('âŒ Projeto nÃ£o encontrado', new Error('Project not found'), {
          input: { projectId }
        });
        throw new Error('Project not found');
      }

      logger.info('âœ… Projeto encontrado', {
        output: {
          projectId: project.id,
          projectName: project.name,
          visionModel: project.visionModel
        }
      });

      // ValidaÃ§Ã£o do modelo de visÃ£o
      logger.debug('ðŸ” Validando modelo de visÃ£o', {
        input: { visionModel: project.visionModel }
      });
      const visionModel = visionModels[project.visionModel];

      if (!visionModel) {
        logger.error('âŒ Modelo de visÃ£o nÃ£o encontrado', new Error('Vision model not found'), {
          input: { visionModel: project.visionModel }
        });
        throw new Error('Vision model not found');
      }

      logger.info('âœ… Modelo de visÃ£o validado', {
        output: {
          modelId: project.visionModel,
          replicateModel: visionModel.replicateModel,
          modelName: visionModel.name
        }
      });

      // Processamento da URL da imagem
      let parsedUrl = url;
      logger.debug('ðŸ–¼ï¸ Processando URL da imagem', {
        input: { originalUrl: url, isProduction: process.env.NODE_ENV === 'production' }
      });

      if (process.env.NODE_ENV !== 'production') {
        logger.debug('ðŸ”„ Convertendo imagem para base64 (ambiente de desenvolvimento)');
        const response = await fetch(url);
        const blob = await response.blob();
        parsedUrl = `data:${blob.type};base64,${Buffer.from(await blob.arrayBuffer()).toString('base64')}`;
        logger.info('âœ… Imagem convertida para base64', {
          metadata: {
            originalSize: blob.size,
            mimeType: blob.type,
            base64Length: parsedUrl.length
          }
        });
      }

      // Chamada para a API do Replicate
      const apiInput = {
        prompt: 'Descreva esta imagem em detalhes.',
        image: parsedUrl,
        max_tokens: 500,
      };

      logger.info('ðŸš€ Iniciando chamada para API Replicate', {
        input: {
          model: visionModel.replicateModel,
          prompt: apiInput.prompt,
          maxTokens: apiInput.max_tokens,
          imageSize: parsedUrl.length
        }
      });

      const output = await logApiCall(
        'Replicate',
        visionModel.replicateModel,
        () => replicate.run(visionModel.replicateModel, { input: apiInput }),
        apiInput
      );

      logger.info('âœ… Resposta recebida da API Replicate', {
        output: {
          outputType: typeof output,
          isArray: Array.isArray(output),
          outputLength: Array.isArray(output) ? output.length : (typeof output === 'string' ? output.length : 'N/A')
        }
      });

      // Processamento da resposta
      const description = Array.isArray(output) ? output.join('') : output;

      if (!description || typeof description !== 'string') {
        logger.error('âŒ DescriÃ§Ã£o invÃ¡lida recebida', new Error('No description found'), {
          output: { description, outputType: typeof description }
        });
        throw new Error('No description found');
      }

      logger.info('ðŸŽ‰ DescriÃ§Ã£o da imagem gerada com sucesso', {
        output: {
          descriptionLength: description.length,
          description: description.substring(0, 100) + (description.length > 100 ? '...' : '')
        },
        metadata: {
          model: visionModel.replicateModel,
          projectId,
          success: true
        }
      });

      return {
        description,
      };
    } catch (error) {
      logger.error('ðŸ’¥ Erro durante anÃ¡lise da imagem', error, {
        input: { url, projectId },
        metadata: { action: 'image_description', success: false }
      });
      
      const message = parseError(error);
      return { error: message };
    }
  }, { url, projectId });
};