'use client';

import { updateProfileAction } from '@/app/actions/profile/update';
import { Canvas } from '@/components/canvas';
import type { ImageNodeProps } from '@/components/nodes/image';
import type { TextNodeProps } from '@/components/nodes/text';
import { Toolbar } from '@/components/toolbar';
import { Button } from '@/components/ui/button';
import { useUser } from '@/hooks/use-user';
import { handleError } from '@/lib/error/handle';
import { nodeButtons } from '@/lib/node-buttons';
import { useProject } from '@/providers/project';
import { useSubscription } from '@/providers/subscription';
import { getIncomers, useReactFlow } from '@xyflow/react';
import { PlayIcon } from 'lucide-react';
import Link from 'next/link';
import { useRouter } from 'next/navigation';
import { useCallback, useEffect, useRef, useState } from 'react';

const TextNode = nodeButtons.find((button) => button.id === 'text');

if (!TextNode) {
  throw new Error('Text node not found');
}

type WelcomeDemoProps = {
  title: string;
  description: string;
};

export const WelcomeDemo = ({ title, description }: WelcomeDemoProps) => {
  const project = useProject();
  const { getNodes, getEdges } = useReactFlow();
  const [started, setStarted] = useState(false);
  const { isSubscribed } = useSubscription();
  const stepsContainerRef = useRef<HTMLDivElement>(null);
  const [hasTextNode, setHasTextNode] = useState(false);
  const [hasFilledTextNode, setHasFilledTextNode] = useState(false);
  const [hasImageNode, setHasImageNode] = useState(false);
  const [hasConnectedImageNode, setHasConnectedImageNode] = useState(false);
  const [hasImageInstructions, setHasImageInstructions] = useState(false);
  const [hasGeneratedImage, setHasGeneratedImage] = useState(false);
  const user = useUser();
  const router = useRouter();

  useEffect(() => {
    // Run on mount to set initial state
    handleNodesChange();
  }, []);

  const handleFinishWelcome = async () => {
    if (!user || !project?.id) {
      return;
    }

    try {
      const response = await updateProfileAction(user.id, {
        onboardedAt: new Date(),
      });

      if ('error' in response) {
        throw new Error(response.error);
      }

      router.push(`/projects/${project.id}`);
    } catch (error) {
      handleError('Error finishing onboarding', error);
    }
  };

  const steps = [
    {
      instructions: `${description} Sound good?`,
      action: (
        <div className="not-prose flex items-center gap-4">
          <Button onClick={() => setStarted(true)}>Sounds good!</Button>
          <Button variant="outline" onClick={handleFinishWelcome}>
            Skip intro
          </Button>
        </div>
      ),
      complete: started,
    },
    {
      instructions: (
        <>
          Before we start, we need to subscribe to the Hobby plan to claim your
          free AI credits. Click the button below to claim your credits. It
          takes a few seconds and doesn't require a credit card.
        </>
      ),
      action: (
        <div className="not-prose">
          <Button asChild>
            <Link href="/pricing">Claim credits</Link>
          </Button>
        </div>
      ),
      complete: isSubscribed,
    },
    {
      instructions: (
        <>
          First, click the{' '}
          <TextNode.icon className="-translate-y-0.5 inline-block size-4 text-primary" />{' '}
          icon on the bottom toolbar. This will add a Text node to the canvas.
        </>
      ),
      complete: hasTextNode,
    },
    {
      instructions: (
        <>
          Fantastic! That's the first node. Because there's no incoming nodes,
          you control the content. Try writing a few words or sentences in the
          node. Our favourite is "a wild field of delphiniums".
        </>
      ),
      complete: hasTextNode && hasFilledTextNode,
    },
    {
      instructions: (
        <>
          Excellent work! Now, let's attach it to an Image node. Drag the handle
          on the right of the Text node into blank space and drop it. You'll be
          prompted to select a node type. Select the Image node.
        </>
      ),
      complete:
        hasTextNode &&
        hasFilledTextNode &&
        hasImageNode &&
        hasConnectedImageNode,
    },
    {
      instructions: (
        <>
          You're getting the hang of it! Because this node has incoming nodes
          connected to it, it will generate content with AI based on the
          incoming nodes.
          <br />
          <br />
          You can also add instructions to the Image node. This will be used to
          influence the outcome. Try adding some instructions to the Image node,
          maybe something like "make it anime style".
        </>
      ),
      complete:
        hasTextNode &&
        hasFilledTextNode &&
        hasImageNode &&
        hasConnectedImageNode &&
        hasImageInstructions,
    },
    {
      instructions: (
        <>
          That's all the information we need to generate an awesome image! Click
          the Image node to select it, then press the{' '}
          <PlayIcon className="-translate-y-0.5 inline-block size-4 text-primary" />{' '}
          button to generate content.
        </>
      ),
      complete:
        hasTextNode &&
        hasFilledTextNode &&
        hasImageNode &&
        hasConnectedImageNode &&
        hasImageInstructions &&
        hasGeneratedImage,
    },
    {
      instructions: (
        <>
          That's it! You've created your first AI-powered workflow. You can
          continue to add more nodes to a canvas to create more complex flows
          and discover the power of WOW.
        </>
      ),
      action: (
        <div className="not-prose">
          <Button asChild onClick={handleFinishWelcome}>
            <Link href="/">Continue</Link>
          </Button>
        </div>
      ),
      complete: false,
    },
  ];

  const activeStep = steps.find((step) => !step.complete) ?? steps[0];
  const previousSteps = steps.slice(0, steps.indexOf(activeStep));

  // biome-ignore lint/correctness/useExhaustiveDependencies: "we want to listen to activeStep"
  useEffect(() => {
    if (stepsContainerRef.current) {
      stepsContainerRef.current.scrollTo({
        top: stepsContainerRef.current.scrollHeight,
        behavior: 'smooth',
      });
    }
  }, [activeStep]);

  const handleNodesChange = useCallback(() => {
    const nodes = getNodes();
    const edges = getEdges();

    const textNodes = nodes.filter((node) => node.type === 'text');
    const imageNodes = nodes.filter((node) => node.type === 'image');

    setHasTextNode(textNodes.length > 0);
    setHasImageNode(imageNodes.length > 0);

    const filledTextNodes = textNodes.filter(
      (node) => (node.data as TextNodeProps).content?.trim()
    );

    setHasFilledTextNode(filledTextNodes.length > 0);

    const connectedImageNodes = imageNodes.filter(
      (node) => getIncomers(node, nodes, edges).length > 0
    );

    setHasConnectedImageNode(connectedImageNodes.length > 0);

    const imageNodesWithInstructions = imageNodes.filter(
      (node) => (node.data as ImageNodeProps).instructions?.trim()
    );

    setHasImageInstructions(imageNodesWithInstructions.length > 0);

    const generatedImageNodes = imageNodes.filter(
      (node) => (node.data as ImageNodeProps).url
    );

    setHasGeneratedImage(generatedImageNodes.length > 0);
  }, [getNodes, getEdges]);

  return (
    <div className="flex h-screen w-screen items-stretch overflow-hidden">
      <div className="relative flex-1">
        <Canvas onNodesChange={handleNodesChange}>
          <Toolbar />
        </Canvas>
      </div>
      <div className="flex w-80 flex-col border-l bg-background">
        <div className="border-b p-6">
          <h1 className="text-2xl font-bold">{title}</h1>
        </div>
        <div
          className="flex-1 overflow-y-auto p-6"
          ref={stepsContainerRef}
        >
          <div className="prose prose-sm max-w-none">
            {previousSteps.map((step, index) => (
              <div key={index} className="mb-6 opacity-50">
                <p>{step.instructions}</p>
                {step.action && (
                  <div className="mt-4">{step.action}</div>
                )}
              </div>
            ))}
            <div className="mb-6">
              <p>{activeStep.instructions}</p>
              {activeStep.action && (
                <div className="mt-4">{activeStep.action}</div>
              )}
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};